[toc]

# 1. 基础

良好的命名习惯：

1. 类名英文字母开头，首字母大写，要采用合适的英文命名，不要使用拼音，使用驼峰命名法
2. 变量名、方法名一般首字母小写，采用驼峰命名法
3. 常量名一般全大写，用下划线分隔



一个`.java`文件中`public`修饰的类类名必须和文件名一致，同样的，一个`.java`文件必须有一个类且仅有这一个类是`public`修饰，其他类一般不加修饰符。



注释：

注释可以辅助代码的理解，不是程序的一部分，所以编译器会自动忽略注释。Java提供三种注释方法：

```java
//方法一：这是一条单行注释

/*
 方法二：
 这是多行注释
 这是多行注释
 这是多行注释
*/
 
/**
 *这是特殊的注释，写在类、方法的定义处，可以用于自动创建文档
 *@param 
 *@return 
 */
```



# 2. 数据类型

**分类：八大基本数据类型+引用类型：**

1. 4整型：
   1. byte（8位1字节）范围 -2^7——2^7-1，默认0
   2. short（16位2字节）范围 -2^15——2^15-1，默认0
   3. int（32位4字节）范围 -2^31——2^31-1，默认0 （最常用）
   4. long（64位8字节）范围 -2^63——2^63-1，默认0l
2. 2浮点：
   1. float（32位4字节）默认：0.0f 必须标注f
   2. double（64位8字节）默认：0.0d或省略0.0 （最常用）

3. 1字符：
   1. char（8位1字节）默认' '，为空
4. 1布尔
   1. boolean（只有true和false两种取值）默认为false

5. 引用
   1. 比如像String类一样的其他用户自定义类或者java自带类，**默认为null**

**注意：**

> 1. 基本数据据类型有对应的BigNumber，其为Java对象，可以表示任意精度；
>
> 2. java中整型值不能和布尔值进行相互转换，c++中可以互相转换；
>
> 3. 从Java7开始，加上前缀0b或者0B可以表示二进制数；还可以在字面量比如整型数隔三加下划线"__"，java编译器会除去这些下划线；
>
> 4. 浮点数值计算可能存在出乎意料的误差，这是由于浮点数是由二进制系统表示的，所以在金融计算中不能使用浮点类型，而应该使用BigDecimal类；
>
> 5. 浮点型表示溢出和出错情况的三种特殊的浮点数值：
>
>    - 正无穷大
>    - 负无穷大
>    - NaN（不是一个数字）
>
>    对应的Java中的表示为：
>
>    - Double.POSITIVE_INFINITY
>    - Double.NEGATIVE_INFINITY
>    - Double.NaN
>
>    检测一个特定值为非数值采取下面这种方法：
>
>    ```java
>    if（Double.isNaN(x)）	//检查x是否是非数值
>    ```



# 3. 变量

变量即初中数学中代数的概念；在Java中，变量分为两种：基本类型的变量和引用类型的变量。

变量必须先定义后使用，在定义时应该给其赋值，如果不复制，变量默认初始化为0、0.0、“”或者false；

变量因为可以重新被赋值，所以应用普遍；

在JDK12中，可以使用关键字`var`定义变量，如

```java
var sb = new StringBuilder();
```

一般的变量作用范围为定义所在的大括号内和此大括号嵌套的大括号中。

```
{
    ...
    int i = 0; // 变量i从这里开始定义
    ...
    {
        ...
        int x = 1; // 变量x从这里开始定义
        ...
        {
            ...
            String s = "hello"; // 变量s从这里开始定义
            ...
        } // 变量s作用域到此结束
        ...
        // 注意，这是一个新的变量s，它和上面的变量同名，
        // 但是因为作用域不同，它们是两个不同的变量:
        String s = "hi";
        ...
    } // 变量x和s作用域到此结束
    ...
} // 变量i作用域到此结束
```

定义变量时，要遵循作用域最小化原则，尽量将变量定义在尽可能小的作用域，并且，不要重复使用变量名。



# 4. 常量

使用`final`修饰的变量即为常量，常量不可修改，但是内容可修改

```java
public class Hello {

    public static final StringBuilder sb = new StringBuilder();

    public Hello() {
        sb.append("我是sb");
    }

    public void addSb() {
        sb.append("+1");
    }

    public String getSb() {
        System.out.println(String.valueOf(sb));
        return String.valueOf(sb);
    }

    public static void main(String[] args) {
        var a = new Hello();
        a.getSb();
        a.addSb();
        a.getSb();
    }
}

//输出结果：
我是sb
我是sb+1+1
```



# 5. 运算

## 5.1 整数运算

Java整数运算加减乘除得到的结果都只会是整数；

针对除法，Java的处理是截取掉小数部分，并不是四舍五入；

求余数即求模使用`%`，如`8%3`

需要注意到，基本数据类型采取补码形式，即有正负数，而且不同数据类型表示的范围也不同；

其实基本数据类型的取值是个圆圈，比如说`byte`类型取值为-128到0，然后0到127，如果再+1的话又是-128；所以发生溢出的话就会像这样循环取值。

自增运算（直接看例子吧，自减类似）：

```java
int n1 = 10;
int n2 = 10;
int temp1,temp2;
temp1 = n1++;		//temp1 = 10;	n1 = 11
temp2 = ++n2;		//temp2 = 11; 	n2 = 11;
```

**移位运算：**

Java使用`<<`表示左移，`>>`表示右移；

移位位数为整数，左移n位，即原数乘2的n次方；右移n位，即原数除2的n次方；这里说的乘除和整数运算的乘除规则一致，即得到的都是截取掉小数部分的整数。

**位运算：**

位运算是按位进行与、或、非和异或的运算。

与运算的规则是，必须两个数同时为`1`，结果才为`1`：

```
n = 0 & 0; // 0
n = 0 & 1; // 0
n = 1 & 0; // 0
n = 1 & 1; // 1
```

或运算的规则是，只要任意一个为`1`，结果就为`1`：

```
n = 0 | 0; // 0
n = 0 | 1; // 1
n = 1 | 0; // 1
n = 1 | 1; // 1
```

非运算的规则是，`0`和`1`互换：

```
n = ~0; // 1
n = ~1; // 0
```

异或运算的规则是，如果两个数不同，结果为`1`，否则为`0`：

```
n = 0 ^ 0; // 0
n = 0 ^ 1; // 1
n = 1 ^ 0; // 1
n = 1 ^ 1; // 0
```

对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如：

```
int i = 167776589; // 00001010 00000000 00010001 01001101
int n = 167776512; // 00001010 00000000 00010001 00000000
System.out.println(i & n); // 167776512
```

**运算优先级：**

在Java的计算表达式中，运算优先级从高到低依次是：

- `()`
- `!` `~` `++` `--`
- `*` `/` `%`
- `+` `-`
- `<<` `>>` `>>>`
- `&`
- `|`
- `+=` `-=` `*=` `/=`

记不住也没关系，只需要加括号就可以保证运算的优先级正确。

**类型转换：**

类型转换有两种：

1. 类型自动提升：如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，`short`和`int`计算，结果总是`int`，原因是`short`首先自动被转型为`int`；

2. 强制类型转换：即将大范围的整数转型为小范围的整数。强制转型使用`(类型)`；强制类型转换如果转换后类型如果溢出，则运算结果不准确，如：

   ```java
   int a = 128;
   byte b = (byte) a;
   System.out.println(b);
   //输出：-128
   ```



## 5.2 浮点数运算

浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。

在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示。

举个栗子：

浮点数`0.1`在计算机中就无法精确表示，因为十进制的`0.1`换算成二进制是一个无限循环小数，很显然，无论使用`float`还是`double`，都只能存储一个`0.1`的近似值。但是，`0.5`这个浮点数又可以精确地表示。

因为浮点数常常无法精确表示，因此，浮点数运算会产生误差：

```java
public class Main {
    public static void main(String[] args) {
        double x = 1.0 / 10;
        double y = 1 - 9.0 / 10;
        // 观察x和y是否相等:
        System.out.println(x);
        System.out.println(y);
    }
}
//输出：
0.1
0.09999999999999998
```

由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数

在浮点数和整数的运算中，整数会自动提升为浮点型，但是注意，两个整数的运算还是得到整数，即使是两个整数的相除再加上一个浮点数。

**溢出：**

整数运算在除数为`0`时会报错，而浮点数运算在除数为`0`时，不会报错，但会返回几个特殊值：

- `NaN`表示Not a Number
- `Infinity`表示无穷大
- `-Infinity`表示负无穷大

**强制转型：**

可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。

如果要进行四舍五入，可以对浮点数加上0.5再强制转型



## 5.3 布尔运算

对于布尔类型`boolean`，永远只有`true`和`false`两个值。

布尔运算是一种关系运算，包括以下几类，且运算符的优先级从高到低依次是：

- `!`
- `>`，`>=`，`<`，`<=`
- `==`，`!=`
- `&&`
- `||`

**短路运算：**

布尔运算的一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。

因为`false && x`的结果总是`false`，无论`x`是`true`还是`false`，因此，与运算在确定第一个值为`false`后，不再继续计算，而是直接返回`false`。

**三元运算符：**

Java还提供一个三元运算符`b ? x : y`，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果。

这里注意，是返回两个表达式之一的计算结果，所以，三元运算符b的值应该赋值给某个变量。



# 6字符和字符串

在Java中，字符和字符串是两个不同的类型。

## 6.1 字符

字符类型`char`是基本数据类型，它是`character`的缩写，用单引号`'a'`括起来一个字符来表示。一个`char`保存一个Unicode字符，也就是说，也可以用Unicode编码强转为`char`类型：

```java
int n1 = 'A'; // 字母“A”的Unicodde编码是65
int n2 = '中'; // 汉字“中”的Unicode编码是20013
```

## 6.2 字符串类型

和`char`类型不同，字符串类型`String`是引用类型，我们用双引号`"..."`表示字符串。一个字符串可以存储0个到任意个字符：

因为字符串使用双引号`"..."`表示开始和结束，那如果字符串本身恰好包含一个`"`字符怎么表示？例如，`"abc"xyz"`，编译器就无法判断中间的引号究竟是字符串的一部分还是表示字符串结束。这个时候，我们需要借助转义字符`\`：

```java
String s = "abc\"xyz"; // 包含7个字符: a, b, c, ", x, y, z
```

常见的转义字符包括：

- `\"` 表示字符`"`
- `\'` 表示字符`'`
- `\\` 表示字符`\`
- `\n` 表示换行符
- `\r` 表示回车符
- `\t` 表示Tab
- `\u####` 表示一个Unicode编码的字符



**不可变特性：**

Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。

这样设计的好处是：编译器可以让字符串共享。

java中的字符串不像c++中一样等于一个char数组，而是类似于char*指针，**因为java有自动垃圾回收机制**，所以尽管是将字符串放置在堆内存中，但是程序员可以不用管它。

执行`String s = "hello";`时，JVM虚拟机先创建字符串`"hello"`，然后，把字符串变量`s`指向它：

```ascii
      s
      │
      ▼
┌───┬───────────┬───┐
│   │  "hello"  │   │
└───┴───────────┴───┘
```

紧接着，执行`s = "world";`时，JVM虚拟机先创建字符串`"world"`，然后，把字符串变量`s`指向它：

```ascii
      s ──────────────┐
                      │
                      ▼
┌───┬───────────┬───┬───────────┬───┐
│   │  "hello"  │   │  "world"  │   │
└───┴───────────┴───┴───────────┴───┘
```

原来的字符串`"hello"`还在，只是我们无法通过变量`s`访问它而已。因此，字符串的不可变是指字符串内容不可变。



**字符串连接：**

Java的编译器对字符串做了特殊照顾，可以使用`+`连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。

但是，如果是在一个很复杂的循环中每次都进行依次字符串连接，则每次都会创建一个新的字符串变量，因为字符串不可变的特性，就会极大的消耗内存；更好的办法是使用可变长度字符串类型`StringBuilder`：

```java
StringBuilder sb = new StringBuilder("sb");
sb.append("add");		//等效于“sb"+"add",但是不会创建新变量
```

**使用可变长度的字符串的两个类**：（对象的值能进行多次修改，而且不产生新的未使用对象）

1. StringBuilder：用于**单线程**中编辑，**线程不安全（不能同步访问），但是速度快**
2. StringBuffer：用于**多线程**，**线程安全，但速度较之较慢**

（两种类的API是相同的，但是单线程中StringBuilder的效率更高）

面试题：

**JAVA 中的 StringBuilder 和 StringBuffer 适用的场景是什么？**

最简单的回答是，stringbuffer 基本没有适用场景，你应该在所有的情况下选择使用 stringbuiler，除非你真的遇到了一个需要线程安全的场景，如果遇到了，请务必在这里留言通知我。

然后，补充一点，关于线程安全，即使你真的遇到了这样的场景，很不幸的是，恐怕你仍然有 99.99....99% 的情况下没有必要选择 stringbuffer，因为 stringbuffer 的线程安全，仅仅是保证 jvm 不抛出异常顺利的往下执行而已，它可不保证逻辑正确和调用顺序正确。大多数时候，我们需要的不仅仅是线程安全，而是锁。

最后，为什么会有 stringbuffer 的存在，如果真的没有价值，为什么 jdk 会提供这个类？答案太简单了，因为最早是没有 stringbuilder 的，sun 的人不知处于何种愚蠢的考虑，决定让 stringbuffer 是线程安全的，然后大约 10 年之后，人们终于意识到这是一个多么愚蠢的决定，意识到在这 10 年之中这个愚蠢的决定为 java 运行速度慢这样的流言贡献了多大的力量，于是，在 jdk1.5 的时候，终于决定提供一个非线程安全的 stringbuffer 实现，并命名为 stringbuilder。顺便，javac 好像大概也是从这个版本开始，把所有用加号连接的 String 运算都隐式的改写成 stringbuilder，也就是说，从 jdk1.5 开始，用加号拼接字符串已经没有任何性能损失了。

如诸多评论所指出的，我上面说，"用加号拼接字符串已经没有任何性能损失了"并不严谨，严格的说，如果没有循环的情况下，单行用加号拼接字符串是没有性能损失的，java 编译器会隐式的替换成 stringbuilder，但在有循环的情况下，编译器没法做到足够智能的替换，仍然会有不必要的性能损耗，因此，用循环拼接字符串的时候，还是老老实实的用 stringbuilder 吧。



**空值null：**

引用类型的变量可以指向一个空值`null`，它表示不存在，即该变量不指向任何对象。

注意要区分空值`null`和空字符串`""`，空字符串是一个有效的字符串对象，它不等于`null`。

字符串的基本判断：

1. 空串判断：

   ```java
   	if(str.length() == 0)	//法一
       if(str.equals(""))		//法二
   ```

2. Null串判断

   ```java
   	if(str == null)
   ```

3. **两种都需要判断（&&采用短路判断方式，必须要首先检查str不为Null，因为在null值上调用方法会出现错误）**

   ```java
   	if(str != null && str.length() != 0)	
   ```



**检测字符串是否相等**：

**必须使用equals方法，不能使用“==”；**

​	如果比较的是两个值相同的String类型字符串用“==“结果为true，这是因为String字符串是共享的；如果换成”+“或者substring，得到的字符串不是共享的，即使值相同，结果也会是false；

​	（上面的内容是《java核心技术卷一》当中的内容，但是在IDEA中发现使用“+”连接的字符串仍旧相等，只有使用substring结果是false，结果如下：）

```java
 public static void main(String[] args) {
        System.out.println("\"abc\".equals(\"abc\")" + "：" + "abc".equals("abc"));
        System.out.println("\"abc\".equals(\"a\" + \"b\" + \"c\")" + "：" + "abc".equals("a" + "b" + "c"));
        System.out.println("\"abc\".equals(\"abcd\".substring(0,3))" + "：" + "abc".equals("abcd".substring(0, 3)));
        System.out.println("\"abc\" == \"abc\"" + "：" + ("abc" == "abc"));
        System.out.println("\"abc\"==(\"a\"+\"b\"+\"c\")" + "：" + ("abc" == ("a" + "b" + "c")));
        System.out.println("\"abc\" == \"abcd\".substring(0, 3)" + "：" + ("abc" == "abcd".substring(0, 3)));
    }
```

```
//结果
"abc".equals("abc")：true
"abc".equals("a" + "b" + "c")：true
"abc".equals("abcd".substring(0,3))：true
"abc" == "abc"：true
"abc"==("a"+"b"+"c")：true
"abc" == "abcd".substring(0, 3)：false
```



# 7. 输入输出

1. 在控制台的简单输入输出:

   1. 控制台输出：

      ```java
      	System.out.print("输出信息1");	//输出内容后，接下来的内容紧跟该输出内容后
      	System.out.println("输出信息2");	//输出内容后换行，常用作无参，表示空一行
      	System.out.prnitf("%8.2f",x);	//格式化输出，更多内容参看《Java核心技术卷Ⅰ》p58，或者菜鸟教程JAVA
      	（每一个以%字符开始的格式说明符都用相应的参数替换）
      ```

   2. 控制台输入（调用Scanner类进行输入）：

      ```java
      	Scanner in = new Scanner(System.in);
      	in.nextInt; 		//in.nextDouble,in.nextLine,常用方法参看p57页Scanner类
      ```

      需要知道的是：in.next读取的是一段不包括空格的字符串，而不是一个字符；

      ```java
      	public static void main(String[] args) {
              Scanner in = new Scanner(System.in);
              ArrayList<String> arrayList = new ArrayList<>();
              while (!in.hasNext("exit")) {
                  arrayList.add(in.next());
              }
              for (String a : arrayList) {
                  System.out.println(a);
              }
          }
      //输入：（注意exit也必须是一个next，所以不能包含其他字符）
      我是1号 我是2号 我是3号，这是附加内容 exit
      //输出：
      我是1号
      我是2号
      我是3号，这是附加内容
      ```

      使用Console类进行控制台输入不可见的输入：

      > 注意：
      >
      > 1. 这个在输入密码的时候不是全是***，而是完全不可见的状态
      > 2. Console这个类在IDEA等编译器下不能使用，会报空指针错误；在我尝试下，目前我知道的是在Windows的Power Shell下可以编译并运行
      >
      > 

      ```java
          public static void main(String[] args) {
              Console console = System.console();
              String name = console.readLine("Name:");
              char[] password = console.readPassword("Password:");
              System.out.println();
              
              System.out.println("Name:"+name);
              System.out.print("Password:");
              for (char aPassword : password) {
                  System.out.print(aPassword);
              }
          }
      ```

2. 文件输入和输出（更常用的方法应该是IO流中的工具类）

   1. 如果对文件进行读取，需要一个用File对象构造一个Scanner对象，如下所示

   ```java
   	Scanner in = new Scanner(Paths.get("myfile.txt"),"UTF-8");
   	//如果文件名中包含反斜杠，记住每个反斜杠之前再加一个额外的反斜杠
   
   	//注意：如果使用下面这种方式，则Scanner将字符串解释为数据，而不是文件名	
   	Scanner in = new Scanner("myfile.txt"); 
   ```

   2. 如果写入文件，需要构造一个PrintWriter对象，如下所示

   ```java
   	PrintWriter out = new PrintWriter("myfile.txt"，"UTF-8");
   	//如果文件不存在，则创建该文件
   ```

   注意：

    1. 在IDE中启动路径由IDE控制，得到路径位置用下面语句

       ```java
       	String dir = System.getProperty("user.dir");
       ```

   2. 定位文件可以使用相对路径和绝对路径，如果觉得定位文件位置比较烦恼，可以使用绝对路径

   3. **如果用一个不存在的文件构造一个Scanner进行文件读取，或者用一个不能被创建的文件名构造一个PrintWriter，那么就会发生异常，而且Java编译器认为这些异常比”被0除“更严重，所以我们需要在方法中用throw子句标记，如下所示：**

      ```java
      public static void main(String[] args) throw IOException
      {
          //假如”myfile.txt“不存在
      	Scanner in = new Scanner(Pahts.get("myfile.txt"),"UTF-8");
          ...
      }
      ```

      
