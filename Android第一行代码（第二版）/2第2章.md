[toc]



## 关于android gradle依赖

> 博客来源：https://www.jianshu.com/p/f34c179bc9d0

在Gradle 2.x版本中，添加依赖主要是使用`compile`

在Gradle 3.x版本及以后，添加依赖被`api`和`implementation`替代：

> **api**：跟 2.x 版本的 `compile`完全相同
> **implementation**：使用了该命令编译的依赖，它仅仅对当前的`Module`提供接口。
>
> **建议**
>  在`Google IO` 相关话题的中提到了一个建议，就是依赖首先应该设置为`implement`的，如果没有错，那就用`implement`，如果有错，那么使用`api`指令，这样会使编译速度有所增快。
>
> **那为什么要这么做呢？**
>  答案是： 1. 加快编译速度。2. 隐藏对外不必要的接口。
>
> **为什么能加快编译速度呢？**
>  这对于大型项目含有多个`Module`模块的， 以上图为例，比如我们改动 `LibraryC` 接口的相关代码，这时候编译只需要单独编译`LibraryA`模块就行， 如果使用的是`api`或者旧时代的`compile`，由于`App Module` 也可以访问到 `LibraryC`,所以 `App Module`部分也需要重新编译。当然这是在全编的情况下。



## 布局Layout

目前（可能是AS 3.6及其以后）更加注重视图和逻辑的分离，并且默认显示的是可视化窗口，而不是xml文件代码，是希望开发者习惯通过拖拽的形式进行快速界面构造；但是，身为Android开发者，两者都应该要熟练使用



## Android Manifest

所有的活动必须在Android Manifest中注册，并且必须至少拥有一个主活动，主活动的声明如下；主活动中设置了`android:lable`属性后，会覆盖外层的该属性，并且主活动的标题栏、该App名称都会变成主活动中设置的`lable`；

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.activitytest">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity
            android:name=".FirstActivity"
            android:label="Android测试">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```



## 新建一个活动

虽然现在新建一个活动很简单，直接右键`java`文件夹下的包名，然后new -> Activity -> 选择合适的Activity，然后修改活动名字，其他默认即可，AS会自动帮你完成好后续操作，但是我们有必要清楚具体流程：

1. 直接右键`java`文件夹下的包名 -> new -> Activity -> 选择合适的Activity，然后在新建页面取消选中`Generate Layout File`，修改名字为`FirstActivity`后点击`Finish`，AS会自动定义一个`onCreate()`方法

2. 右键`res`文件夹新建一个`Dorectory`，命名为`layout`，注意是小写；然后右键`layout`新建一个`Layout resource file`，命名为`first_layout`，注意，全是小写，用下划线分隔，一般名字和活动名保持一致

3. 在Android Manifest中注册，但是你会发现AS自动帮你写好了你创建的这个活动，但是由于目前只有一个活动，没有主活动，所以你需要将你创建的这个活动声明为主活动，添加如下内容即可

   ```xml
   <activity android:name=".FirstActivity">
       <intent-filter>
           <action android:name="android.intent.action.MAIN" />
           <category android:name="android.intent.category.LAUNCHER" />
       </intent-filter>
   </activity>
   ```

   

### 使用Toast

Toast是Android提供的一种提醒方式，可以在一小段时间内提供一段信息给用户，在之后自动消失，并且不会占用任何屏幕空间；一般情况下Toast结合点击事件使用；

Toast调用的`makeText`方法传入三个参数：

1. 上下文（Context对象，一般都是本活动，如`MainActivity.this`，注意一定要加`.this`）
2. 显示的文本内容（String）
3. 显示的时长，需为两个内置常量之一：`Toast.LENGTH_SHORT`和`Toast.LENGTH_LONG`

最后不要忘记调用`show()`方法

注意：这种方法是使用Android自带的Toast样式，但是一般情况下的需求都需要自定义Toast

```java
import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {
    private static final String TAG = "MainActivity";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //绑定button
        Button button = findViewById(R.id.button);

        //添加点击事件
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //传入三个参数编写Toast
                Toast.makeText(MainActivity.this, "这是一个Toast", Toast.LENGTH_LONG).show();
            }
        });
    }
}

```



### 在活动中使用Menu

Android的Menu会显示在右上方，即标题栏的最右侧，一般是竖着的三个点；

1. 右键res目录 -> New -> Directory，输入文件夹名mnu，点击OK；

2. 右键menu文件夹 -> New -> Menu resource file，新建一个名为main的文件，然后添加几个item

3. 然后回到待创建Menu的活动中，重写`onCreateOptionsMenu()`方法，重写快捷键为`ctrl+O`

   ```java
   @Override
   public boolean onCreateOptionsMenu(Menu menu) {
       getMenuInflater().inflate(R.menu.main,menu);
       //此处返回为true，表示允许创建的菜单显示出来
       return true;
   }
   ```

注意：使用这种方法的时候是不需要在该活动的Layout文件中编写布局的



### 销毁一个活动

两种方法：

1. 按back键销毁活动
2. 使用Activity类提供的`finish()`方法



## 使用Intent

Intent一般用于活动间的跳转和活动间数据的传递，还可以打开手机上某些应用

### 显示Intent

假如你现在创建有两个活动：`MainActivity`和`SecondActivity`，那么在`MainActivity`跳转到另一个的代码就很简单；一般是在一个点击事件中进行跳转，比如说按下一个`Button`，就进行跳转；跳转之后按下back键即可销毁当前活动回到前一个活动

```java
	Button button = findViewById(R.id.button);
	button.setOnClickListener(new View.OnClickListener){
        @Override
        public void onClick(){
            Intent intent = new Intent(MainActivity.this, SecondActivity.class);
			startActivity(intent);                
        }
    }
```

注意：`Intent`的构造函数有多个重载，显示`Intent`最常用的就是上面这种两个参数，第一个参数为启动活动的上下文（Context），第二个参数为指定想要启动的目标活动（Class），注意后缀。



### 隐式Intent

隐式Intent不明确指出要启动哪一个活动，而是通过设置Android Mainfest中的action和category然后交给系统去分析这个Intent，让其找出合适的活动去启动。具体方法如下：

1. 在Android Manifest中对指定活动下的<intent-filter>设置action和category；（注意：action只有一个，category可以有多个）

   ```xml
   <activity android:name=".SecondActivity">
        <!--注意此处最好指定包名，提高辨识度-->
       <intent-filter>
           <action android:name="com.eaxmple.helloworld.new_ACTION" />
   
           <category android:name="android.intent.category.DEFAULT" />
       </intent-filter>
   
   </activity>
   ```

2. 在要使用的点击事件中使用隐式Intent，使用`Intent(String action)`构造方法传入指定`action`，使用`intent.addCategory(String category)`来添加指定`category`，如果1中设置的为`android.intent.category.DEFAULT`，则不用使用`intent.addCategory(String category)`

   ```java
   Button button = findViewById(R.id.button2);
   button.setOnClickListener(new View.OnClickListener() {
       @Override
       public void onClick(View view) {
           Intent a = new Intent("com.eaxmple.helloworld.new_ACTION");
           startActivity(a);
       }
   });
   ```

注意：

- 每个Intent只能指定一个action，但却能指定多个category
- 必须action和category都匹配才能正常运行，否则无法正常运行；但是如果是`android.intent.category.DEFAULT`，则不用指明categroy



### 更多隐式Intent用法

隐式Intent不仅可以启动自己的App中的活动，还可以启动其他应用程序的活动；`Intent`类中提供了许多常量值，用来打开指定的程序；如打开一个网页可用下列方法：

```java
Button button = findViewById(R.id.button);

button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setData(Uri.parse("http://www.baidu.com"));
        startActivity(intent);
    }
});
```

注意：

- 这里的`Intent.ACTION_VIEW`就是Android系统内置的动作，为常量值，这里就是`"android.intent.action.VIEW"`
- `Intent.setData()`方法接受一个`Uri`类型的参数，这个类为Android提供的类，类似于Java中的`URL`类
- 除了http协议外，还可以指定很多其他协议，比如geo表示显示地理位置，tel表示拨打电话。
- 与此对应，我们可以在<intent-filter>标签再配置一个<data>标签，用于更精确地指定当前活动能够响应什么类型的数据（注意：只有<data>标签中指定的内容和Intent中携带的Data完全一致时，当前活动才能响应）
  - android：scheme。用于指定数据的协议部分，如http或者https
  - android：host。用于指定数据的主机名部分，如www.bilibili.com
  - android：port。用于指定数据的端口部分，一般紧随在主机名后面
  - android：path。用于指定主机名和端口之后的部分
  - android：mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定



### 向下一个活动传递数据

活动之间一般使用`Intent`传递数据

**传递数据：**

`Intent`中使用`putExtra()`方法传递数据，此方法接受两个参数：参数一为键（String），参数二为值（有多种数据类型的重载）
传递数据后，再使用`startActivity()`跳转到另一个活动

```java
button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        Intent intent = new Intent(MainActivity.this, SecondActivity.class);
        intent.putExtra("extra_data", "Hello, Second Activity");
        startActivity(intent);
    }
});
```

**接收数据：**

首先使用`Activity`类中的静态方法`getIntent()`得到一个`Intent`实例，再用这个实例获取传递过来的数据，有多种方法接受不同的数据，如接受`String`类型的数据就使用`getStringExtra()`方法，此方法接受一个参数，参数为键（String）

```java
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_second);

    Intent intent = getIntent();
    String msg = intent.getStringExtra("extra_data");
    Log.d(TAG, msg);
}
```



### 返回数据给上一个活动

Activity中的`startActivityForResult()`方法期望再活动销毁的时候能够返回一个结果给上一个活动。
此方法接受两个参数：参数一为`Intent`对象，参数二为请求码，用于在之后的回调中判断数据的来源，一般设置为1

1. 在MainActivity中按钮的点击事件中使用`startActivityForResult()`方法代替`startActivity()`方法

   ```java
   button.setOnClickListener(new View.OnClickListener() {
       @Override
       public void onClick(View view) {
           Intent intent = new Intent(MainActivity.this, SecondActivity.class);
           //参数二为回调onActivityResult中得到的请求码
           startActivityForResult(intent, 1);
       }
   });
   ```

2. 在SecondActivity中也设置一个按钮，添加一个点击事件，用作销毁当前活动，退回到上一个活动，并将数据传送给上一个活动

   ```java
   button.setOnClickListener(new View.OnClickListener() {
       @Override
       public void onClick(View view) {
           Intent intent = new Intent();
           intent.putExtra("data_return", "Hello, MainActivity");
           //setResult()方法非常重要，是专门用于向上一个活动返回数据的，参数一为回调onActivityResult中得到的结果码
           setResult(RESULT_OK, intent);
           finish();
       }
   });
   ```

3. 由于是使用`startActivityForResult()`方法启动SecondActivity的，在SecondActivity被销毁之后会回调上一个活动的`onActivityResult()`方法，因此我们需要在`MainActivity()`中重写这个方法来得到返回的数据

   ```java
   @Override
       protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
           super.onActivityResult(requestCode, resultCode, data);
           switch (requestCode) {
               case 1:
                   if (resultCode == RESULT_OK) {
                       String returnData = data.getStringExtra("data_return");
                       Log.d(TAG, returnData);
                   }
                   break;
               default:
                   break;
           }
       }
   ```

**注意：**

1. 有请求码和结果码，其中：请求码是处理一个活动中多个按钮打开同一个新的活动；结果码是处理一个活动打开了不同的新活动，但是这些新活动销毁后都是返回同一个活动。具体可参考博客：https://www.cnblogs.com/zgqys1980/p/5286208.html

2. Log中的TAG是一个实例域变量，值为当前活动名

3. 如果用户没有通过点击按钮，而是通过back键回到MainActivity，一般情况下设计为数据返回不成功，但是也可以通过back键设置数据返回，我们则需要在SecondActivity中重写`onBackPressed()`方法来解决

   ```java
   @Override
   public void onBackPressed() {
       Intent intent = new Intent();
       intent.putExtra("data_return", "Hello, First");
       setResult(RESULT_OK, intent);
       finish();
   }
   ```

   

## 活动的生命周期

### 返回栈

Android是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称为**返回栈（Back Stack）**。

栈是一种**先进后出**的数据结构，默认情况下，每启动一个新的活动，这个新活动就被入栈且位于栈顶显示给用户；而每按下Back键或者调用`finish()`方法，则销毁这个活动的同时将位于栈顶的活动出栈，前一个入栈的活动就位于栈顶显示给用户。系统总是会显示处于栈顶的活动给用户。



### 活动状态

每个活动在其生命周期中最多可能会有4种状态

1. **运行状态**

   当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。

2. **暂停状态**

   当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。

3. **停止状态**

   当一个活动不再处于栈顶位置，并且完全不可见时，就进入了停止状态。

4. **销毁状态**

   当一个活动从返回栈种移除后就变成了销毁状态



### 活动的生存期

Activity类定义了7个回调方法，覆盖了活动生命周期的每一个环节

1. **onCreate()**

   每个活动必须重写此方法，它会在活动第一次被创建时被调用。你应该在这个方法种完成活动的初始化操作，比如加载布局、绑定事件，当然，更推荐的写法是加载布局和绑定事件用方法分开写，然后再在onCreate()方法中调用

2. **onStart()**

   这个方法在活动由不可见变为可见时调用

3. **onResume()**

   这个方法在活动准备好和用户进行交互时调用。此时的活动一定位于返回栈栈顶，并且处于运行状态

4. **onPause()**

   这个方法在系统准备去启动或者恢复两一个活动的时候调用。我们通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要块，不然会影响到新的栈顶活动的使用

5. **onStop()**

   这个方法在活动完全不可用的时候调用。它和`onPause()`方法的主要区别在于，如果启动的新活动是一个对话框活动，那么`onPause()`方法会得到执行，而`onStop()`方法并不会执行

6. **onDestory()**

   这个方法在活动被销毁之前调用，之后活动状态将变为销毁状态

7. **onRestart()**

   这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了

以上7个方法中除了`onRestart()`方法，其他都是两两相对的，从而又可以将活动分为3种生存期：

1. **完整生存期**

   活动在`onCreate()`方法和`onDestroy()`方法之间所经历的，就是完整生存期。一般情况下，一个活动会在`onCreate()`方法种完成各种初始化操作，而在`onDestroy()`方法种完成释放内存的操作

2. **可见生存期**

   活动在`onStart()`和`onStop()`方法之间所经历的，就是可见生存期。在可见生存期内，活动对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法，合理地管理那些对用户可见的资源。比如在onStart()方法中对资源进行加载，而在onStop()方法中对资源进行释放，从而保证处于停止状态的活动不会占用过多内存

3. **前台生存期**

   活动在onResume()方法和onPause()方法之间所经历的就是前台生存期。在前台生存期内，活动总是处于运行状态的，此时的活动时可以和用户进行交互的，我们平时看到和接触最多的也就是这个状态下的活动

![活动的生命周期](https://developer.android.google.cn/guide/components/images/activity_lifecycle.png?hl=zh-cn)



### 体验活动的生命周期

新建一个空活动，两个子活动：一个为`NormalActivity`，一个为`DialogActivity`；其中`DialogActivity`在Android Manifest中设置主题为Dialog；主活动设置两个按钮，分别跳转到这两个活动即可。

```xml
<activity android:name=".DialogActivity"
	android:theme="@style/Theme.AppCompat.Dialog">
</activity>
```

MainActivity代码：

```java
public class MainActivity extends AppCompatActivity {

    private static final String TAG = "MainActivity";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d(TAG, "onCreate");
        setContentView(R.layout.activity_main);

        Button nor = findViewById(R.id.normal_button);
        Button dia = findViewById(R.id.dialog_button);

        nor.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                startActivity(new Intent(MainActivity.this, NormalActivity.class));
            }
        });

        dia.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                startActivity(new Intent(MainActivity.this, DialogActivity.class));
            }
        });
    }

    @Override
    protected void onStart() {
        super.onStart();
        Log.d(TAG, "onStart");
    }

    @Override
    protected void onResume() {
        super.onResume();
        Log.d(TAG, "onResume");
    }

    @Override
    protected void onPause() {
        super.onPause();
        Log.d(TAG, "onPause");
    }

    @Override
    protected void onStop() {
        super.onStop();
        Log.d(TAG, "onStop");
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "onDestroy");
    }

    @Override
    protected void onRestart() {
        super.onRestart();
        Log.d(TAG, "onRestart");
    }
}
```

使用logcat过滤TAG为MainActivity的日志如下：

```verilog
//打开App
2020-07-23 11:47:16.101 5217-5217/com.example.activitylifecycletest D/MainActivity: onCreate
2020-07-23 11:47:16.189 5217-5217/com.example.activitylifecycletest D/MainActivity: onStart
2020-07-23 11:47:16.191 5217-5217/com.example.activitylifecycletest D/MainActivity: onResume
//打开Normal Activity
2020-07-23 11:49:11.659 5217-5217/com.example.activitylifecycletest D/MainActivity: onPause
2020-07-23 11:49:12.268 5217-5217/com.example.activitylifecycletest D/MainActivity: onStop
//退出Normal Activity到Main Activity
2020-07-23 11:49:45.408 5217-5217/com.example.activitylifecycletest D/MainActivity: onRestart
2020-07-23 11:49:45.411 5217-5217/com.example.activitylifecycletest D/MainActivity: onStart
2020-07-23 11:49:45.412 5217-5217/com.example.activitylifecycletest D/MainActivity: onResume
//打开Dialog Activity
2020-07-23 11:50:31.687 5217-5217/com.example.activitylifecycletest D/MainActivity: onPause
//退出Dialog Activity到Main Activity
2020-07-23 11:50:59.796 5217-5217/com.example.activitylifecycletest D/MainActivity: onResume
//退出Main Activity到桌面
2020-07-23 11:51:36.396 5217-5217/com.example.activitylifecycletest D/MainActivity: onPause
2020-07-23 11:51:37.078 5217-5217/com.example.activitylifecycletest D/MainActivity: onStop
2020-07-23 11:51:37.078 5217-5217/com.example.activitylifecycletest D/MainActivity: onDestroy
```



### 活动被回收了怎么办

在活动A基础上打开活动B，可能会系统内存不足，活动A会被回收掉，这时，如果点击back键返回到活动A，活动A如果有数据输入，会丢失已填写数据；因为这时并不是执行的`onRestart()`方法，而是执行活动A的`onCreate()`方法，严重影响用户体验。

解决办法是使用Activity类提供的`onSaveInstanceState()`回调方法，此方法可以保证在活动被回收之前一定会被调用，因此我们可以通过这个方法来解决数据得不到保存的问题。

1. 在`onSaveInstanceState()`方法中，提供了一个`Bundle`类型的参数，其提供了一系列保存数据的方法，如`putString()`保存字符串，以此类推，其使用键值对进行存储。

   ```java
   @Override
   protected void onSaveInstanceState(@NonNull Bundle outState) {
       super.onSaveInstanceState(outState);
       outState.putString("str_key", "This is data");
   }
   ```

2. 恢复数据：在`onCreate()`方法中，提供的参数也是`Bundle`，一般为null，如果在活动被系统回收之前有通过`onSaveInstanceState()`方法保存数据的话，这个参数就会带有之前所保存的数据

   ```java
   @Override
   protected void onCreate(Bundle savedInstanceState) {
       super.onCreate(savedInstanceState);
       setContentView(R.layout.activity_main);
   
       if (savedInstanceState != null) {
           String data = savedInstanceState.getString("str_key");
           Log.d(TAG, data);
       }
   }
   ```



## 活动的启动模式

启动模式一共4种，可以在Android Manifest种通过给activity标签指定`android：launchMode`属性来选择启动模式

1. **standard**

   在没有显式指定启动模式，则默认采用此模式

   Android是使用返回栈来管理活动的，在此模式下，每当启动一个新的活动，它就会在返回栈中入栈并位于栈顶的位置。

   但是对于此模式下的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例

   ```java
   button.setOnClickListener(new View.OnClickListener){
       @override
       public void onClick(View v){
           startActivity(new Intent(MainActivity.this,MainActivity.class));
       }
   };
   ```

   在上面的代码中，每点击一次MainActivity的按钮，就会创建一个新的活动实例，并且跳转过去，比如你点三下，你就得返回三次，挺别扭的，对吧。

2. **singleTop**

   此模式需要在Android Manifest种通过给activity标签指定`android：launchMode`属性来选择`singleTop`启动模式

   此模式下，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例

   修改了启动模式之后再试试上面的代码，你会发现无论你点多少次按钮都没有反应，因为没有创建新的活动实例

3. **singleTask**

   此模式需要在Android Manifest种通过给activity标签指定`android：launchMode`属性来选择`singleTask`启动模式

   此模式下，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动出栈，如果没有发现就会创建一个新的活动实例

   此模式修复了如果活动实例没在顶层的情况下新建活动实例的问题

4. **singleInstance**

   此模式下的活动会启用一个新的返回栈来管理这个活动（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈）。这样做有什么意义呢？假设我们的程序中有一个活动是允许其他程序调用的，如果我们想实现其他程序和我们程序可以共享这个活动的实例，前三种是办不到的，因为每个程序都有自己的返回栈，同一个活动在不同的返回栈中入栈时必定时创建了新的实例。

   可以调用Activity的`getTaskId()`方法得到当前活动所在的栈 id 。



## 活动的最佳实践

### 知晓当前是在哪一个活动

当在阅读别人的代码时，找不到某个界面对应的活动是哪个。

可以创建一个`BaseActivity`类，并且修改所有活动的继承结构，让所有活动不继承自`AppCompatActivity`，而是继承`BaseActivity`类，此类如下：

```java
public class BaseActivity extends AppCompatActivity{
    
    @Override
    public void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        Log.d("BaseActivity",getClass().getSimpleName());
    }
}
```

在运行App的时候，使用logcat筛选BaseActivity标签，即可确定当前活动



### 随即随地退出程序

如果你目前界面停留在ThirdActivity，如果退出的话要按三次back键，或者按home键，再清除所有挂起的程序。如果要实现随时退出程序，只需要用一个专门的集合类对所有活动进行管理。

1. 新建一个ActivityCollector类作为活动管理器

   ```java
   import android.app.Activity;
   
   import java.util.ArrayList;
   import java.util.List;
   
   public class ActivityCollector {
   
       public static List<Activity> activities = new ArrayList<>();
   
       public static void addActivity(Activity activity) {
           activities.add(activity);
       }
   
       public static void removeActivity(Activity activity) {
           activities.remove(activity);
       }
   
       public static void finishAll() {
           for (Activity activity : activities) {
               if (!activity.isFinishing()) {
                   activity.finish();
               }
           }
           activities.clear();
       }
   }
   ```

2. 修改BaseActivity中的代码

   ```java
   import androidx.appcompat.app.AppCompatActivity;
   
   import android.os.Bundle;
   import android.util.Log;
   
   public class BaseActivity extends AppCompatActivity {
   
       @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           Log.d("BaseActivity", getClass().getSimpleName());
           ActivityCollector.addActivity(this);
       }
   
       @Override
       protected void onDestroy() {
           super.onDestroy();
           ActivityCollector.removeActivity(this);
       }
   }
   ```

3. 从此以后，不管你想在什么地方退出程序，只需要调用`ActivityCollector.finishAll()`即可

   注意：此方法关闭了其他所有活动，但是当前进程并没有被销毁，如果要保证完全退出，需要加上一行代码

   ```java
   android.os.Process.killProcess(android.os.Process.myPid());
   ```



### 启动活动的最佳玩法

一般的启动活动很简单，无非就是构建好intent的意图，然后使用startActivity或者startActivityForResult方法启动活动

```java
Intent intent = new Intent(FirstActivity.this,SecondActivity.class);
intent.putExtra("param1","data1");
intent.putExtra("param2","data2");
startActivity(intent);
```

有时你接手别人的程序，你并不清楚这个活动需要传递哪些数据，你可以修改一下SecondActivity的代码

```java
public class SecondActivity extends BaseActivity{
    ...;
    public static void actionStart(Context context,String data1,String data2){
		Intent intent = new Intent(context,SeconActivity.class);
        intent.putExtra("param1",data1);
        intent.putExtra("param2",data2);
    }
}
```

然后在FirstActivity中跳转的时候，直接写如下代码即可替代第一种

```java
SecondActivity.actionStart(FirstActivity.this,"data1","data2");
```

这样写的好处重点是一目了然，SecondActivity所需的数据在方法参数中全都体现出来了，这样即使不用阅读SecondActivity中的代码，不去询问负责编写SecondActivity的同事，你也可以非常清晰知道启动SecondActivity需要传递哪些数据。